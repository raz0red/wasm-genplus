/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./src/main/js/genplus.js":
/*!********************************!*\
  !*** ./src/main/js/genplus.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__filename, process, __dirname, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar Module = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n\n  if (true) _scriptDir = _scriptDir || __filename;\n  return function (Module) {\n    Module = Module || {};\n    var Module = typeof Module !== \"undefined\" ? Module : {};\n    var readyPromiseResolve, readyPromiseReject;\n    Module[\"ready\"] = new Promise(function (resolve, reject) {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    var moduleOverrides = {};\n    var key;\n\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n\n    var arguments_ = [];\n    var thisProgram = \"./this.program\";\n\n    var quit_ = function quit_(status, toThrow) {\n      throw toThrow;\n    };\n\n    var ENVIRONMENT_IS_WEB = false;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n    ENVIRONMENT_IS_WEB = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\";\n    ENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\n    ENVIRONMENT_IS_NODE = (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === \"object\" && _typeof(process.versions) === \"object\" && typeof process.versions.node === \"string\";\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n    var scriptDirectory = \"\";\n\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      }\n\n      return scriptDirectory + path;\n    }\n\n    var read_, readAsync, readBinary, setWindowTitle;\n    var nodeFS;\n    var nodePath;\n\n    if (ENVIRONMENT_IS_NODE) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\").dirname(scriptDirectory) + \"/\";\n      } else {\n        scriptDirectory = __dirname + \"/\";\n      }\n\n      read_ = function shell_read(filename, binary) {\n        if (!nodeFS) nodeFS = __webpack_require__(/*! fs */ \"fs\");\n        if (!nodePath) nodePath = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n        filename = nodePath[\"normalize\"](filename);\n        return nodeFS[\"readFileSync\"](filename, binary ? null : \"utf8\");\n      };\n\n      readBinary = function readBinary(filename) {\n        var ret = read_(filename, true);\n\n        if (!ret.buffer) {\n          ret = new Uint8Array(ret);\n        }\n\n        assert(ret.buffer);\n        return ret;\n      };\n\n      if (process[\"argv\"].length > 1) {\n        thisProgram = process[\"argv\"][1].replace(/\\\\/g, \"/\");\n      }\n\n      arguments_ = process[\"argv\"].slice(2);\n      process[\"on\"](\"uncaughtException\", function (ex) {\n        if (!(ex instanceof ExitStatus)) {\n          throw ex;\n        }\n      });\n      process[\"on\"](\"unhandledRejection\", abort);\n\n      quit_ = function quit_(status) {\n        process[\"exit\"](status);\n      };\n\n      Module[\"inspect\"] = function () {\n        return \"[Emscripten Module object]\";\n      };\n    } else if (ENVIRONMENT_IS_SHELL) {\n      if (typeof read != \"undefined\") {\n        read_ = function shell_read(f) {\n          return read(f);\n        };\n      }\n\n      readBinary = function readBinary(f) {\n        var data;\n\n        if (typeof readbuffer === \"function\") {\n          return new Uint8Array(readbuffer(f));\n        }\n\n        data = read(f, \"binary\");\n        assert(_typeof(data) === \"object\");\n        return data;\n      };\n\n      if (typeof scriptArgs != \"undefined\") {\n        arguments_ = scriptArgs;\n      } else if (typeof arguments != \"undefined\") {\n        arguments_ = arguments;\n      }\n\n      if (typeof quit === \"function\") {\n        quit_ = function quit_(status) {\n          quit(status);\n        };\n      }\n\n      if (typeof print !== \"undefined\") {\n        if (typeof console === \"undefined\") console = {};\n        console.log = print;\n        console.warn = console.error = typeof printErr !== \"undefined\" ? printErr : print;\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\"/\") + 1);\n      } else {\n        scriptDirectory = \"\";\n      }\n\n      {\n        read_ = function shell_read(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.send(null);\n          return xhr.responseText;\n        };\n\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = function readBinary(url) {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            xhr.responseType = \"arraybuffer\";\n            xhr.send(null);\n            return new Uint8Array(xhr.response);\n          };\n        }\n\n        readAsync = function readAsync(url, onload, onerror) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, true);\n          xhr.responseType = \"arraybuffer\";\n\n          xhr.onload = function xhr_onload() {\n            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n              onload(xhr.response);\n              return;\n            }\n\n            onerror();\n          };\n\n          xhr.onerror = onerror;\n          xhr.send(null);\n        };\n      }\n\n      setWindowTitle = function setWindowTitle(title) {\n        document.title = title;\n      };\n    } else {}\n\n    var out = Module[\"print\"] || console.log.bind(console);\n    var err = Module[\"printErr\"] || console.warn.bind(console);\n\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    }\n\n    moduleOverrides = null;\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n    if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n    var tempRet0 = 0;\n\n    var setTempRet0 = function setTempRet0(value) {\n      tempRet0 = value;\n    };\n\n    var getTempRet0 = function getTempRet0() {\n      return tempRet0;\n    };\n\n    var wasmBinary;\n    if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n    var noExitRuntime;\n    if (Module[\"noExitRuntime\"]) noExitRuntime = Module[\"noExitRuntime\"];\n\n    if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) !== \"object\") {\n      abort(\"no native wasm support detected\");\n    }\n\n    var wasmMemory;\n    var wasmTable;\n    var ABORT = false;\n    var EXITSTATUS = 0;\n\n    function assert(condition, text) {\n      if (!condition) {\n        abort(\"Assertion failed: \" + text);\n      }\n    }\n\n    var UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\n    function UTF8ArrayToString(heap, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n\n      while (heap[endPtr] && !(endPtr >= endIdx)) {\n        ++endPtr;\n      }\n\n      if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(heap.subarray(idx, endPtr));\n      } else {\n        var str = \"\";\n\n        while (idx < endPtr) {\n          var u0 = heap[idx++];\n\n          if (!(u0 & 128)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n\n          var u1 = heap[idx++] & 63;\n\n          if ((u0 & 224) == 192) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n\n          var u2 = heap[idx++] & 63;\n\n          if ((u0 & 240) == 224) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\n          }\n\n          if (u0 < 65536) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 65536;\n            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n          }\n        }\n      }\n\n      return str;\n    }\n\n    function UTF8ToString(ptr, maxBytesToRead) {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n    }\n\n    var WASM_PAGE_SIZE = 65536;\n\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n\n      return x;\n    }\n\n    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\n    function updateGlobalBufferAndViews(buf) {\n      buffer = buf;\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\n    }\n\n    var INITIAL_INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 33554432;\n\n    if (Module[\"wasmMemory\"]) {\n      wasmMemory = Module[\"wasmMemory\"];\n    } else {\n      wasmMemory = new WebAssembly.Memory({\n        \"initial\": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,\n        \"maximum\": 2147483648 / WASM_PAGE_SIZE\n      });\n    }\n\n    if (wasmMemory) {\n      buffer = wasmMemory.buffer;\n    }\n\n    INITIAL_INITIAL_MEMORY = buffer.byteLength;\n    updateGlobalBufferAndViews(buffer);\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATMAIN__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function initRuntime() {\n      runtimeInitialized = true;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function preMain() {\n      callRuntimeCallbacks(__ATMAIN__);\n    }\n\n    function postRun() {\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n\n    Module[\"preloadedImages\"] = {};\n    Module[\"preloadedAudios\"] = {};\n\n    function abort(what) {\n      if (Module[\"onAbort\"]) {\n        Module[\"onAbort\"](what);\n      }\n\n      what += \"\";\n      err(what);\n      ABORT = true;\n      EXITSTATUS = 1;\n      what = \"abort(\" + what + \"). Build with -s ASSERTIONS=1 for more info.\";\n      var e = new WebAssembly.RuntimeError(what);\n      readyPromiseReject(e);\n      throw e;\n    }\n\n    function hasPrefix(str, prefix) {\n      return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;\n    }\n\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n\n    function isDataURI(filename) {\n      return hasPrefix(filename, dataURIPrefix);\n    }\n\n    var fileURIPrefix = \"file://\";\n\n    function isFileURI(filename) {\n      return hasPrefix(filename, fileURIPrefix);\n    }\n\n    var wasmBinaryFile = \"genplus.wasm\";\n\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n\n    function getBinary() {\n      try {\n        if (wasmBinary) {\n          return new Uint8Array(wasmBinary);\n        }\n\n        if (readBinary) {\n          return readBinary(wasmBinaryFile);\n        } else {\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n      } catch (err) {\n        abort(err);\n      }\n    }\n\n    function getBinaryPromise() {\n      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === \"function\" && !isFileURI(wasmBinaryFile)) {\n        return fetch(wasmBinaryFile, {\n          credentials: \"same-origin\"\n        }).then(function (response) {\n          if (!response[\"ok\"]) {\n            throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n          }\n\n          return response[\"arrayBuffer\"]();\n        })[\"catch\"](function () {\n          return getBinary();\n        });\n      }\n\n      return Promise.resolve().then(getBinary);\n    }\n\n    function createWasm() {\n      var info = {\n        \"a\": asmLibraryArg\n      };\n\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n        Module[\"asm\"] = exports;\n        wasmTable = Module[\"asm\"][\"o\"];\n        removeRunDependency(\"wasm-instantiate\");\n      }\n\n      addRunDependency(\"wasm-instantiate\");\n\n      function receiveInstantiatedSource(output) {\n        receiveInstance(output[\"instance\"]);\n      }\n\n      function instantiateArrayBuffer(receiver) {\n        return getBinaryPromise().then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        }).then(receiver, function (reason) {\n          err(\"failed to asynchronously prepare wasm: \" + reason);\n          abort(reason);\n        });\n      }\n\n      function instantiateAsync() {\n        if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === \"function\") {\n          fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }).then(function (response) {\n            var result = WebAssembly.instantiateStreaming(response, info);\n            return result.then(receiveInstantiatedSource, function (reason) {\n              err(\"wasm streaming compile failed: \" + reason);\n              err(\"falling back to ArrayBuffer instantiation\");\n              return instantiateArrayBuffer(receiveInstantiatedSource);\n            });\n          });\n        } else {\n          return instantiateArrayBuffer(receiveInstantiatedSource);\n        }\n      }\n\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          var exports = Module[\"instantiateWasm\"](info, receiveInstance);\n          return exports;\n        } catch (e) {\n          err(\"Module.instantiateWasm callback failed with error: \" + e);\n          return false;\n        }\n      }\n\n      instantiateAsync();\n      return {};\n    }\n\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n\n        if (typeof callback == \"function\") {\n          callback(Module);\n          continue;\n        }\n\n        var func = callback.func;\n\n        if (typeof func === \"number\") {\n          if (callback.arg === undefined) {\n            wasmTable.get(func)();\n          } else {\n            wasmTable.get(func)(callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n\n    var PATH = {\n      splitPath: function splitPath(filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: function normalizeArray(parts, allowAboveRoot) {\n        var up = 0;\n\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n\n          if (last === \".\") {\n            parts.splice(i, 1);\n          } else if (last === \"..\") {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift(\"..\");\n          }\n        }\n\n        return parts;\n      },\n      normalize: function normalize(path) {\n        var isAbsolute = path.charAt(0) === \"/\",\n            trailingSlash = path.substr(-1) === \"/\";\n        path = PATH.normalizeArray(path.split(\"/\").filter(function (p) {\n          return !!p;\n        }), !isAbsolute).join(\"/\");\n\n        if (!path && !isAbsolute) {\n          path = \".\";\n        }\n\n        if (path && trailingSlash) {\n          path += \"/\";\n        }\n\n        return (isAbsolute ? \"/\" : \"\") + path;\n      },\n      dirname: function dirname(path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n\n        if (!root && !dir) {\n          return \".\";\n        }\n\n        if (dir) {\n          dir = dir.substr(0, dir.length - 1);\n        }\n\n        return root + dir;\n      },\n      basename: function basename(path) {\n        if (path === \"/\") return \"/\";\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, \"\");\n        var lastSlash = path.lastIndexOf(\"/\");\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      extname: function extname(path) {\n        return PATH.splitPath(path)[3];\n      },\n      join: function join() {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join(\"/\"));\n      },\n      join2: function join2(l, r) {\n        return PATH.normalize(l + \"/\" + r);\n      }\n    };\n    var SYSCALLS = {\n      mappings: {},\n      buffers: [null, [], []],\n      printChar: function printChar(stream, curr) {\n        var buffer = SYSCALLS.buffers[stream];\n\n        if (curr === 0 || curr === 10) {\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n          buffer.length = 0;\n        } else {\n          buffer.push(curr);\n        }\n      },\n      varargs: undefined,\n      get: function get() {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret;\n      },\n      getStr: function getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n      get64: function get64(low, high) {\n        return low;\n      }\n    };\n\n    function ___sys_fcntl64(fd, cmd, varargs) {\n      SYSCALLS.varargs = varargs;\n      return 0;\n    }\n\n    function ___sys_ioctl(fd, op, varargs) {\n      SYSCALLS.varargs = varargs;\n      return 0;\n    }\n\n    function ___sys_open(path, flags, varargs) {\n      SYSCALLS.varargs = varargs;\n    }\n\n    function _longjmp(env, value) {\n      _setThrew(env, value || 1);\n\n      throw \"longjmp\";\n    }\n\n    function _emscripten_longjmp(a0, a1) {\n      return _longjmp(a0, a1);\n    }\n\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.copyWithin(dest, src, src + num);\n    }\n\n    function _emscripten_get_heap_size() {\n      return HEAPU8.length;\n    }\n\n    function emscripten_realloc_buffer(size) {\n      try {\n        wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1;\n      } catch (e) {}\n    }\n\n    function _emscripten_resize_heap(requestedSize) {\n      requestedSize = requestedSize >>> 0;\n\n      var oldSize = _emscripten_get_heap_size();\n\n      var maxHeapSize = 2147483648;\n\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n\n      var minHeapSize = 16777216;\n\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), 65536));\n        var replacement = emscripten_realloc_buffer(newSize);\n\n        if (replacement) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function _fd_close(fd) {\n      return 0;\n    }\n\n    function _fd_read(fd, iov, iovcnt, pnum) {\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var num = SYSCALLS.doReadv(stream, iov, iovcnt);\n      HEAP32[pnum >> 2] = num;\n      return 0;\n    }\n\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}\n\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      var num = 0;\n\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAP32[iov + i * 8 >> 2];\n        var len = HEAP32[iov + (i * 8 + 4) >> 2];\n\n        for (var j = 0; j < len; j++) {\n          SYSCALLS.printChar(fd, HEAPU8[ptr + j]);\n        }\n\n        num += len;\n      }\n\n      HEAP32[pnum >> 2] = num;\n      return 0;\n    }\n\n    function _getTempRet0() {\n      return getTempRet0() | 0;\n    }\n\n    function _setTempRet0($i) {\n      setTempRet0($i | 0);\n    }\n\n    __ATINIT__.push({\n      func: function func() {\n        ___wasm_call_ctors();\n      }\n    });\n\n    var asmLibraryArg = {\n      \"h\": ___sys_fcntl64,\n      \"j\": ___sys_ioctl,\n      \"k\": ___sys_open,\n      \"c\": _emscripten_longjmp,\n      \"m\": _emscripten_memcpy_big,\n      \"n\": _emscripten_resize_heap,\n      \"g\": _fd_close,\n      \"i\": _fd_read,\n      \"l\": _fd_seek,\n      \"f\": _fd_write,\n      \"d\": _getTempRet0,\n      \"e\": invoke_v,\n      \"a\": wasmMemory,\n      \"b\": _setTempRet0\n    };\n    var asm = createWasm();\n\n    var ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function () {\n      return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"p\"]).apply(null, arguments);\n    };\n\n    var _wasm_input_update = Module[\"_wasm_input_update\"] = function () {\n      return (_wasm_input_update = Module[\"_wasm_input_update\"] = Module[\"asm\"][\"q\"]).apply(null, arguments);\n    };\n\n    var _init = Module[\"_init\"] = function () {\n      return (_init = Module[\"_init\"] = Module[\"asm\"][\"r\"]).apply(null, arguments);\n    };\n\n    var _start = Module[\"_start\"] = function () {\n      return (_start = Module[\"_start\"] = Module[\"asm\"][\"s\"]).apply(null, arguments);\n    };\n\n    var _tick = Module[\"_tick\"] = function () {\n      return (_tick = Module[\"_tick\"] = Module[\"asm\"][\"t\"]).apply(null, arguments);\n    };\n\n    var _sound = Module[\"_sound\"] = function () {\n      return (_sound = Module[\"_sound\"] = Module[\"asm\"][\"u\"]).apply(null, arguments);\n    };\n\n    var _get_rom_buffer_ref = Module[\"_get_rom_buffer_ref\"] = function () {\n      return (_get_rom_buffer_ref = Module[\"_get_rom_buffer_ref\"] = Module[\"asm\"][\"v\"]).apply(null, arguments);\n    };\n\n    var _get_frame_buffer_ref = Module[\"_get_frame_buffer_ref\"] = function () {\n      return (_get_frame_buffer_ref = Module[\"_get_frame_buffer_ref\"] = Module[\"asm\"][\"w\"]).apply(null, arguments);\n    };\n\n    var _get_web_audio_l_ref = Module[\"_get_web_audio_l_ref\"] = function () {\n      return (_get_web_audio_l_ref = Module[\"_get_web_audio_l_ref\"] = Module[\"asm\"][\"x\"]).apply(null, arguments);\n    };\n\n    var _get_web_audio_r_ref = Module[\"_get_web_audio_r_ref\"] = function () {\n      return (_get_web_audio_r_ref = Module[\"_get_web_audio_r_ref\"] = Module[\"asm\"][\"y\"]).apply(null, arguments);\n    };\n\n    var _get_input_buffer_ref = Module[\"_get_input_buffer_ref\"] = function () {\n      return (_get_input_buffer_ref = Module[\"_get_input_buffer_ref\"] = Module[\"asm\"][\"z\"]).apply(null, arguments);\n    };\n\n    var stackSave = Module[\"stackSave\"] = function () {\n      return (stackSave = Module[\"stackSave\"] = Module[\"asm\"][\"A\"]).apply(null, arguments);\n    };\n\n    var stackRestore = Module[\"stackRestore\"] = function () {\n      return (stackRestore = Module[\"stackRestore\"] = Module[\"asm\"][\"B\"]).apply(null, arguments);\n    };\n\n    var _setThrew = Module[\"_setThrew\"] = function () {\n      return (_setThrew = Module[\"_setThrew\"] = Module[\"asm\"][\"C\"]).apply(null, arguments);\n    };\n\n    function invoke_v(index) {\n      var sp = stackSave();\n\n      try {\n        wasmTable.get(index)();\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0 && e !== \"longjmp\") throw e;\n\n        _setThrew(1, 0);\n      }\n    }\n\n    var calledRun;\n\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + status + \")\";\n      this.status = status;\n    }\n\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n\n    function run(args) {\n      args = args || arguments_;\n\n      if (runDependencies > 0) {\n        return;\n      }\n\n      preRun();\n      if (runDependencies > 0) return;\n\n      function doRun() {\n        if (calledRun) return;\n        calledRun = true;\n        Module[\"calledRun\"] = true;\n        if (ABORT) return;\n        initRuntime();\n        preMain();\n        readyPromiseResolve(Module);\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n        postRun();\n      }\n\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n\n    Module[\"run\"] = run;\n\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n\n    noExitRuntime = true;\n    run();\n    return Module.ready;\n  };\n}();\n\nif (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = Module;else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  return Module;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n/* WEBPACK VAR INJECTION */}.call(this, \"/index.js\", __webpack_require__(/*! ./../../../node_modules/process/browser.js */ \"./node_modules/process/browser.js\"), \"/\", __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./src/main/js/genplus.js?");

/***/ }),

/***/ "./src/main/js/genplus.wasm":
/*!**********************************!*\
  !*** ./src/main/js/genplus.wasm ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"genplus.wasm\");\n\n//# sourceURL=webpack:///./src/main/js/genplus.wasm?");

/***/ }),

/***/ "./src/main/js/index.js":
/*!******************************!*\
  !*** ./src/main/js/index.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _genplus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./genplus.js */ \"./src/main/js/genplus.js\");\n/* harmony import */ var _genplus_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_genplus_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _genplus_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./genplus.wasm */ \"./src/main/js/genplus.wasm\");\n\n\n\n(function () {\n  var ROM_PATH = './roms/sonic2.bin';\n  var CANVAS_WIDTH = 320;\n  var CANVAS_HEIGHT = 224; // TODO: Garbage in last 2 lines (Sonic 2)\n\n  var SOUND_FREQUENCY = 48000;\n  var SAMPLING_PER_FPS = 48000 / 60 + 100;\n  var GAMEPAD_API_INDEX = 32;\n  var DEBUG = false; // emulator\n\n  var gens;\n  var romdata;\n  var vram;\n  var input;\n  var initialized = false;\n  var vsync = true; // canvas member\n\n  var canvas;\n  var canvasContext;\n  var canvasImageData; // fps control\n\n  var FPS = 60; // audio member\n\n  var SOUNDBUFSIZE = 8192 << 1;\n  var mixbuffer = [new Array(SOUNDBUFSIZE), new Array(SOUNDBUFSIZE)];\n  var audio_l;\n  var audio_r;\n  var audioCtx = null;\n  var audioNode = null;\n  var mixhead = 0;\n  var mixtail = 0; // timing\n\n  var forceAdjustTimestamp = false;\n  var hidden, visibilityChange; // for iOS\n\n  var isSafari = false;\n\n  var keyscan = function keyscan() {\n    input.fill(0);\n    var gamepads = navigator.getGamepads();\n    if (gamepads.length == 0) return;\n    var gamepad = gamepads[0];\n    if (gamepad == null) return;\n\n    if (isSafari) {\n      // for iOS Microsoft XBOX ONE\n      // UP - DOWN\n      input[7] = gamepad.axes[5] * -1; // LEFT - RIGHT\n\n      input[6] = gamepad.axes[4];\n    } else if (gamepad.id.match(/Microsoft/)) {\n      // for Microsoft XBOX ONE\n      // axes 0 - 7\n      gamepad.axes.forEach(function (value, index) {\n        input[index] = value;\n      });\n    } else {\n      // UP - DOWN\n      input[7] = gamepad.axes[1]; // LEFT - RIGHT\n\n      input[6] = gamepad.axes[0];\n    } // GamePadAPI   MEGADRIVE\n    // input[8 + 2] INPUT_A;\n    // input[8 + 3] INPUT_B;\n    // input[8 + 1] INPUT_C;\n    // input[8 + 7] INPUT_START;\n    // input[8 + 0] INPUT_X;\n    // input[8 + 4] INPUT_Y;\n    // input[8 + 5] INPUT_Z;\n    // input[8 + 6] INPUT_MODE;\n\n\n    gamepad.buttons.forEach(function (button, index) {\n      input[index + 8] = button.value;\n    });\n  };\n\n  var storeSound = function storeSound(l, r, length) {\n    //console.log(length);\n    for (var i = 0; i < length; i++) {\n      mixbuffer[0][mixhead] = l[i];\n      mixbuffer[1][mixhead++] = r[i];\n      if (mixhead == SOUNDBUFSIZE) mixhead = 0;\n    }\n  };\n\n  var sync = function sync(callback, afterTimeout) {\n    if (vsync) {\n      requestAnimationFrame(callback);\n    } else {\n      if (!afterTimeout) {\n        setTimeout(callback, 0);\n      } else {\n        callback();\n      }\n    }\n  };\n\n  var loop = function loop() {\n    // update keys\n    keyscan(); // update\n\n    gens._tick(); // draw\n\n\n    canvasImageData.data.set(vram);\n    canvasContext.putImageData(canvasImageData, 0, 0); // sound\n\n    var samples = gens._sound();\n\n    storeSound(audio_l, audio_r, samples);\n  };\n\n  var startLoop = function startLoop() {\n    var start = Date.now();\n    var fc = 0;\n    var frequency = FPS;\n    var debugFrequency = frequency * 10;\n    var frameTicks = 1000.0 / frequency;\n    var adjustTolerance = frameTicks * frequency * 2; // 2 secs\n\n    var avgWait = 0;\n    console.log(\"Frame ticks: \" + frameTicks);\n    console.log(\"Frequency: \" + frequency);\n\n    var f = function f() {\n      loop();\n      nextTimestamp += frameTicks;\n      var now = Date.now();\n\n      if (nextTimestamp + adjustTolerance < now || forceAdjustTimestamp) {\n        forceAdjustTimestamp = false;\n        nextTimestamp = now;\n        fc = 0;\n        start = now;\n        avgWait = 0;\n        console.log(\"adjusted next timestamp.\");\n      }\n\n      var wait = nextTimestamp - now;\n      avgWait += wait;\n\n      if (wait > 0) {\n        setTimeout(function () {\n          return sync(f, true);\n        }, wait);\n      } else {\n        sync(f, false);\n      }\n\n      fc++;\n\n      if (fc % debugFrequency == 0) {\n        var elapsed = Date.now() - start;\n\n        if (DEBUG) {\n          console.log(\"v:%s, vsync: %d\", (1000.0 / (elapsed / fc)).toFixed(2), vsync ? 1 : 0, vsync ? \"\" : \"wait: \" + (avgWait / fc * frequency).toFixed(2) + \", \");\n        }\n\n        start = Date.now();\n        fc = 0;\n        avgWait = 0;\n      }\n    };\n\n    var nextTimestamp = Date.now() + frameTicks;\n    setTimeout(function () {\n      return sync(f, true);\n    }, nextTimestamp);\n  };\n\n  var start = function start() {\n    if (!initialized) return; // Prepare canvas\n\n    canvas = document.getElementById('screen');\n    canvas.setAttribute('width', CANVAS_WIDTH);\n    canvas.setAttribute('height', CANVAS_HEIGHT);\n    canvasContext = canvas.getContext('2d');\n    canvasImageData = canvasContext.createImageData(CANVAS_WIDTH, CANVAS_HEIGHT);\n    canvasContext.clearRect(0, 0, canvas.width, canvas.height); // emulator start\n\n    gens._start(); // vram view\n\n\n    vram = new Uint8ClampedArray(gens.HEAPU8.buffer, gens._get_frame_buffer_ref(), CANVAS_WIDTH * CANVAS_HEIGHT * 4); // audio view\n\n    audio_l = new Float32Array(gens.HEAPF32.buffer, gens._get_web_audio_l_ref(), SAMPLING_PER_FPS);\n    audio_r = new Float32Array(gens.HEAPF32.buffer, gens._get_web_audio_r_ref(), SAMPLING_PER_FPS); // input\n\n    input = new Float32Array(gens.HEAPF32.buffer, gens._get_input_buffer_ref(), GAMEPAD_API_INDEX); // iOS\n\n    var ua = navigator.userAgent;\n\n    if (ua.match(/Safari/) && !ua.match(/Chrome/) && !ua.match(/Edge/)) {\n      isSafari = true;\n    } // game loop\n\n\n    startLoop();\n  };\n\n  var startAudio = function startAudio() {\n    if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) {\n      audioCtx = window.AudioContext ? new window.AudioContext({\n        sampleRate: SOUND_FREQUENCY\n      }) : new window.webkitAudioContext();\n      audioNode = audioCtx.createScriptProcessor(512, 0, 2);\n\n      audioNode.onaudioprocess = function (e) {\n        var ldst = e.outputBuffer.getChannelData(0);\n        var rdst = e.outputBuffer.getChannelData(1);\n        var done = 0;\n        var len = ldst.length;\n\n        while (mixtail != mixhead && done < len) {\n          ldst[done] = mixbuffer[0][mixtail];\n          rdst[done++] = mixbuffer[1][mixtail++];\n          if (mixtail == SOUNDBUFSIZE) mixtail = 0;\n        }\n\n        while (done < len) {\n          ldst[done] = 0;\n          rdst[done++] = 0;\n        }\n      };\n\n      audioNode.connect(audioCtx.destination);\n    }\n  }; // Visibility\n\n\n  var handleVisibilityChange = function handleVisibilityChange() {\n    if (document[hidden]) {\n      forceAdjustTimestamp = true;\n    }\n  };\n\n  if (typeof document.hidden !== \"undefined\") {\n    // Opera 12.10 and Firefox 18 and later support\n    hidden = \"hidden\";\n    visibilityChange = \"visibilitychange\";\n  } else if (typeof document.msHidden !== \"undefined\") {\n    hidden = \"msHidden\";\n    visibilityChange = \"msvisibilitychange\";\n  } else if (typeof document.webkitHidden !== \"undefined\") {\n    hidden = \"webkitHidden\";\n    visibilityChange = \"webkitvisibilitychange\";\n  }\n\n  document.addEventListener(visibilityChange, handleVisibilityChange, false); // Audio resume\n\n  var resumeFunc = function resumeFunc() {\n    if (audioCtx.state !== 'running') audioCtx.resume();\n  };\n\n  var docElement = document.documentElement;\n  docElement.addEventListener(\"keydown\", resumeFunc);\n  docElement.addEventListener(\"click\", resumeFunc);\n  docElement.addEventListener(\"drop\", resumeFunc);\n  docElement.addEventListener(\"dragdrop\", resumeFunc);\n  _genplus_js__WEBPACK_IMPORTED_MODULE_0___default()().then(function (module) {\n    gens = module; // memory allocate\n\n    gens._init(); // load rom\n\n\n    fetch(ROM_PATH).then(function (response) {\n      return response.arrayBuffer();\n    }).then(function (bytes) {\n      // create buffer from wasm\n      romdata = new Uint8Array(gens.HEAPU8.buffer, gens._get_rom_buffer_ref(bytes.byteLength), bytes.byteLength);\n      romdata.set(new Uint8Array(bytes));\n      initialized = true; // start\n\n      startAudio();\n      start();\n    });\n  });\n})();\n\n//# sourceURL=webpack:///./src/main/js/index.js?");

/***/ }),

/***/ "fs":
/*!************************!*\
  !*** external "empty" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = empty;\n\n//# sourceURL=webpack:///external_%22empty%22?");

/***/ })

/******/ });